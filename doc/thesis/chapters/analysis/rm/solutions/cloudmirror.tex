CloudMirror \cite{cloudmirror} allows client applications to specify bandwidth and high availability guarantees.

\subsubsection{Motivation}
Prior models are not suitable to represent interactive non-batch applications with very stringent bandwidth requirements.
Both the hose and the \gls{voc} model are inefficient as they over-allocate bandwidth.
The main reason of why this happens is that both models \textit{aggregate} bandwidth requirements between different application components into a single hose: as a consequence, the \gls{vm} scheduler does not get to know the actual bandwidth needed between application components.
At the opposite extreme there is the pipe model which, besides not exploiting statistical multiplexing, is not scalable since it requires a list of all bandwidth guarantees between pairs of \glspl{vm}.
This led CloudMirror \cite{cloudmirror} inventors to come up with a new model.

\subsubsection{Tenant Application Graph}
The \gls{tag} is a directed graph where each vertex represents an application component and links' weights represent the minimum requested bandwidth. Each vertex can have an optional \textit{size}, denoting the number of \glspl{vm} belonging to the component.\par
There are two types of edges:
\begin{mylist}
    \item self-loop edges, that are equivalent a hose model and
    \item standard vertex-to-vertex edges
\end{mylist}.
A standard edge from vertex $a$ to vertex $b$ is labeled with an ordered pair of numbers $<S, R>$, indicating respectively the guaranteed bandwidth with which \glspl{vm} in $a$ can send traffic to \glspl{vm} in $b$ and the guaranteed bandwidth with which \glspl{vm} in $b$ can receive traffic from \glspl{vm} in $a$: 

\subsubsection{Model advantages}
The edge label format $<S, R>$ allows the model to exploit statistical multiplexing, since $S$ can represent the peak of the sum of \gls{vm}-to-\gls{vm} demands instead of the (typically larger) sum of peak demands needed by the pipe model.
\textbf{\textit{TO BE CONTINUED}} ...

% An heuristic \gls{vm} placement algorithm then tries to solve this NP-hard allocation problem.

% \subsubsection{Characteristics}
    % Architecture:
    % Scheduling work partitioning:
    % Interference:
    % Choice of resources:
    % Preemption:
    % Allocation granularity: